/** Global maximum integer. */

const MAX_INT = Number.MAX_SAFE_INTEGER;

/** At the parsing stage, all parsed node results are kept in an `Either` type (either an AST node) or an Err (error) object. We want to avoid throwing as much as possible for optimal parsing. */
type Either<A, B> = Left<A> | Right<B>;

/** A box type corresponding to failure. */
class Left<T> {
  private value: T;
  constructor(value: T) {
    this.value = value;
  }
  map<A>(f: (x: never) => A): Either<T, never> {
    return this as any;
  }
  isLeft(): this is Left<T> {
    return true;
  }
  isRight(): this is never {
    return false;
  }
  chain<X, S>(f: (x: never) => Either<X, S>): Left<T> {
    return this;
  }
  read<K>(value: K): K {
    return value;
  }
  flatten(): Left<T> {
    return this;
  }
  unwrap() {
    return this.value;
  }
  ap<B, E>(f: Either<T, E>): Either<never, B> {
    return this as any;
  }
}

/** A box type corresponding success. */
class Right<T> {
  private value: T;
  constructor(value: T) {
    this.value = value;
  }
  map<X>(f: (x: T) => X): Either<never, X> {
    return new Right(f(this.value));
  }
  isLeft(): this is never {
    return false;
  }
  isRight(): this is Right<T> {
    return true;
  }
  chain<N, X>(f: (x: T) => Either<N, X>): Either<never, X> {
    return f(this.value) as Either<never, X>;
  }
  flatten(): Right<T extends Right<infer T> ? T : never> {
    return (
      this.value instanceof Right || this.value instanceof Left
        ? this.value
        : this
    ) as Right<T extends Right<infer T> ? T : never>;
  }
  read<K>(_: K): T {
    return this.value;
  }
  unwrap() {
    return this.value;
  }
  ap<B, E>(f: Either<E, (x: T) => B>): Either<never, B> {
    if (f.isLeft()) return f as any as Right<B>;
    return this.map(f.value);
  }
}

/** Returns a new left. */
const left = <T>(x: T): Left<T> => new Left(x);

/** Returns a new right. */
const right = <T>(x: T): Right<T> => new Right(x);
/**
 * Errors in Winnow are classified by type.
 *  * `lexical-error` - an error during scanning.
 *  * `syntax-error` - an error during parsing.
 *  * `type-error` - an error during type-checking.
 *  * `runtime-error` - an error during execution.
 *  * `resolver-error` - an error during resolution.
 *  * `environment-error` - an error during environment lookup.
 */
type ErrorType =
  | "lexical-error"
  | "syntax-error"
  | "type-error"
  | "runtime-error"
  | "resolver-error"
  | "environment-error";

class Erratum extends Error {
  message: string;
  errorType: ErrorType;
  phase: string;
  line: number;
  column: number;
  constructor(
    message: string,
    errorType: ErrorType,
    phase: string,
    line: number,
    column: number
  ) {
    super(message);
    this.message = message;
    this.errorType = errorType;
    this.phase = phase;
    this.line = line;
    this.column = column;
  }
  report() {
    return formattedError(
      this.message,
      this.phase,
      this.errorType,
      this.line,
      this.column
    );
  }
}

/** Ensures all errors have the same format. */
function formattedError(
  message: string,
  phase: string,
  errorType: ErrorType,
  line: number,
  column: number
) {
  let moduleName = "module";
  switch (errorType) {
    case "lexical-error":
      moduleName = "scanner";
      break;
    case "environment-error":
      moduleName = "environment";
      break;
    case "resolver-error":
      moduleName = "resolver";
      break;
    case "runtime-error":
      moduleName = "interpreter";
      break;
    case "syntax-error":
      moduleName = "parser";
      break;
    case "type-error":
      moduleName = "typechecker";
  }
  return `${errorType.toUpperCase()}.\nWhile ${phase}, an error occurred on\nline ${line}, column ${column}.\nReporting from the ${moduleName}:\n${message}`;
}

/** Returns a new error making function. */
const errorFactory =
  (errtype: ErrorType) => (message: string, phase: string, token: Token) =>
    new Erratum(message, errtype, phase, token.line, token.column);

/** Returns a new lexical error. A lexical error is raised if an error occured during scanning. */
const lexicalError = errorFactory("lexical-error");

/** Returns a new syntax error. A syntax error is raised if an error occured during parsing. */
const syntaxError = errorFactory("syntax-error");

/** Returns a new runtime error. A runtime error is raised if an error occured during interpretation. */
const runtimeError = errorFactory("runtime-error");

/** Returns a new environment error. An environment error is raised if an error occured during an environment lookup. */
const envError = errorFactory("environment-error");

/** Returns a new resolver error. A resolver error is raised if an error occured during resolution. */
const resolverError = errorFactory("resolver-error");

/** Returns a tuple. */
function tuple<T extends any[]>(...data: T) {
  return data;
}

/**
 * All tokens generated by Winnow have a TokenType.
 * The TokenType categorizes the token.
 */
enum TokenType {
  // single-character tokens
  left_paren,
  right_paren,
  left_brace,
  right_brace,
  left_bracket,
  right_bracket,
  comma,
  dot,
  minus,
  plus,
  semicolon,
  slash,
  star,
  colon,
  ampersand,
  caret,
  percent,
  vbar,

  // one or two character tokens
  bang,
  bang_equal,
  equal,
  equal_equal,
  greater,
  greater_equal,
  less,
  less_equal,

  // literals
  identifier,
  string,

  // numeric values
  integer,
  float,
  fraction,
  scientific,

  // keywords
  and,
  class,
  else,
  false,
  for,
  if,
  nil,
  or,
  print,
  return,
  super,
  this,
  true,
  var,
  while,
  nan,
  inf,
  pi,
  e,
  let,
  fn,
  rem,
  mod,
  div,
  nor,
  xor,
  xnor,
  not,
  nand,

  // utility tokens
  error,
  eof,
  empty,
}

type NumberTokenType =
  | TokenType.integer
  | TokenType.float
  | TokenType.fraction
  | TokenType.scientific;

type Primitive =
  | string
  | number
  | boolean
  | null
  | Erratum
  | [Primitive, Primitive];

/** An object corresponding to a token in Winnow. */
class Token<T extends TokenType = TokenType, L extends Primitive = Primitive> {
  /** This token's type. */
  tokenType: T;

  /** This token's lexeme. */
  lexeme: string;

  /** The line where this token was recognized. */
  line: number;

  /** The column where this token was recognized. */
  column: number;

  /** This token's literal value, if any. */
  literal: L = null as any;

  constructor(tokenType: T, lexeme: string, line: number, column: number) {
    this.tokenType = tokenType;
    this.lexeme = lexeme;
    this.line = line;
    this.column = column;
  }

  /** Sets this token's literal value to the given primitive, and returns this. */
  lit(value: L) {
    this.literal = value;
    return this;
  }

  /** Returns true if this token is of the given type. */
  isType(type: TokenType) {
    return this.tokenType === type;
  }

  /** Returns a string representation of this token. */
  toString() {
    const type = TokenType[this.tokenType];
    const lexeme = this.lexeme;
    const line = this.line;
    const lit = this.literal;
    return `{Type: ${type}, Lexeme: ${lexeme}, Line: ${line}, Literal: ${lit}}`;
  }

  isErrorToken(): this is Token<TokenType.error, Erratum> {
    return this.isType(TokenType.error);
  }

  static empty = new Token(TokenType.empty, "", -1, -1);
  static end = new Token(TokenType.eof, "", -1, -1);
}

/** Returns a new token. */
const newToken = (
  type: TokenType,
  lexeme: string,
  line: number,
  column: number
) => new Token(type, lexeme, line, column);

/** Returns true if the string `char` is a Latin or Greek character. */
function isLatinGreek(char: string) {
  return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(char);
}

/** Returns true if the given string `char` is within the unicode range `∀-⋿`. Else, returns false. */
function isMathSymbol(char: string) {
  return /^[∀-⋿]/u.test(char);
}

/** Returns true if the given string `char` is a digit. Else, returns false. */
function isDigit(char: string) {
  return "0" <= char && char <= "9";
}

/** Returns true if the given string char is a hex digit. Else, returns false. */
function isHexDigit(char: string) {
  return (
    ("0" <= char && char <= "9") ||
    ("a" <= char && char <= "f") ||
    ("A" <= char && char <= "F")
  );
}

/** Returns true if the given string char is an octal digit. Else, returns false. */
function isOctalDigit(char: string) {
  return "0" <= char && char <= "7";
}

/** Returns true if the given string char is a binary digit. Else, returns false. */
function isBinaryDigit(char: string) {
  return char === "0" || char === "1";
}

/** Returns true if the given string `char` is a Latin/Greek character or a math symbol. Else, returns false. */
function isValidName(char: string) {
  return isLatinGreek(char) || isMathSymbol(char);
}

export function lexical(source: string) {
  /** A counter to keep track of which line we're on. */
  let $line = 1;

  /** A counter to keep track of which column we're on. */
  let $column = 1;

  /** A pointer to where the scanner first starts. */
  let $start = 0;

  /** A pointer to where the scanner currently is.  */
  let $current = 0;

  /** A stateful variable that binds to either an error object or null. If no error occurs during scanning, then this variable must be null. If this variable is not null, then an error must have occurred. */
  let $error: Erratum | null = null;

  /** Returns the character the scanner is currently considering.  */
  const peek = () => source[$current];

  /** Returns the next character the scanner will consider. */
  const peekNext = () => (atEnd() ? "" : source[$current + 1]);

  /**
   * Returns the character
   * n places ahead of current.
   */
  const lookup = (n: number) => (atEnd() ? "" : source[$current + n]);

  /** Returns a substring of the source, starting from where the scanner first started and ending at the current character. */
  const slice = () => source.slice($start, $current);

  /** Returns true if the scanner has reached the end of input. */
  const atEnd = () => $current >= source.length;

  /** Returns a new token. */
  const makeToken = (tokenType: TokenType, lexeme: string = "") => {
    const lex = lexeme ? lexeme : slice();
    const out = newToken(tokenType, lex, $line, $column);
    return out;
  };

  /** Returns a new error token with the given message. */
  const errorToken = (message: string) => {
    const err = newToken(TokenType.error, message, $line, $column);
    const newError = lexicalError(message, "scanning", err);
    $error = newError;
    err.lit(newError);
    return err;
  };

  /** Returns the current character and moves the scanner forward by one character. */
  const tick = () => source[$current++];

  /** Skips all whitespaces. */
  const skipWhitespace = () => {
    while (true) {
      const c = peek();
      switch (c) {
        case " ":
        case "\r":
        case "\t":
          tick();
          $column++;
          break;
        case "\n":
          $line++;
          $column = 0;
          tick();
          break;
        default:
          return;
      }
    }
  };

  /** If the current character matches the expectedChar, moves the scanner foward and returns true. Otherwise, returns false. */
  const match = (expectedChar: string) => {
    if (atEnd()) {
      return false;
    } else if (source[$current] !== expectedChar) {
      return false;
    } else {
      $current++;
      return true;
    }
  };

  /** Returns a string literal token. */
  const stringLiteral = () => {
    while (peek() !== `"` && !atEnd()) {
      if (peek() === `\n`) {
        $line++;
        $column = 0;
      } else {
        $column++;
      }
      tick();
    }
    if (atEnd()) {
      return errorToken("Unterminated string");
    }
    tick();
    const lex = slice().slice(1, -1);
    return makeToken(TokenType.string, lex);
  };

  /** Returns either an identifier or a keyword token. */
  const word = () => {
    while ((isValidName(peek()) || isDigit(peek())) && !atEnd()) {
      tick();
    }
    const string = slice();
    switch (string) {
      case "this":
        return makeToken(TokenType.this);
      case "super":
        return makeToken(TokenType.super);
      case "class":
        return makeToken(TokenType.class);
      case "false":
        return makeToken(TokenType.false);
      case "true":
        return makeToken(TokenType.true);
      case "nan":
        return makeToken(TokenType.nan);
      case "inf":
        return makeToken(TokenType.inf);
      case "pi":
        return makeToken(TokenType.pi);
      case "e":
        return makeToken(TokenType.e);
      case "return":
        return makeToken(TokenType.return);
      case "while":
        return makeToken(TokenType.while);
      case "for":
        return makeToken(TokenType.for);
      case "let":
        return makeToken(TokenType.let);
      case "var":
        return makeToken(TokenType.var);
      case "fn":
        return makeToken(TokenType.fn);
      case "if":
        return makeToken(TokenType.if);
      case "else":
        return makeToken(TokenType.else);
      case "print":
        return makeToken(TokenType.print);
      case "rem":
        return makeToken(TokenType.rem);
      case "mod":
        return makeToken(TokenType.mod);
      case "div":
        return makeToken(TokenType.div);
      case "nil":
        return makeToken(TokenType.nil);
      case "and":
        return makeToken(TokenType.and);
      case "or":
        return makeToken(TokenType.or);
      case "nor":
        return makeToken(TokenType.nor);
      case "xor":
        return makeToken(TokenType.xor);
      case "xnor":
        return makeToken(TokenType.xnor);
      case "not":
        return makeToken(TokenType.not);
      case "nand":
        return makeToken(TokenType.nand);
    }
    return makeToken(TokenType.identifier);
  };

  /** Returns a binary number token. */
  const binaryNumber = () => {
    if (!isBinaryDigit(peek())) {
      return errorToken("Expected binary digits after 0b");
    }
    while ((peek() === "0" || peek() === "1") && !atEnd()) {
      tick();
    }
    const s = slice().replace("0b", "");
    const n = Number.parseInt(s, 2);
    return makeToken(TokenType.integer, `${n}`).lit(n);
  };

  /** Returns an octal number token. */
  const octalNumber = () => {
    if (!isOctalDigit(peek())) {
      return errorToken("Expected octal digits after 0o");
    }
    while (isOctalDigit(peek()) && !atEnd()) {
      tick();
    }
    const s = slice().replace("0o", "");
    const n = Number.parseInt(s, 8);
    return makeToken(TokenType.integer).lit(n);
  };

  /** Returns a hexadecimal number token. */
  const hexNumber = () => {
    if (!isHexDigit(peek())) {
      return errorToken("Expected hexadecimals after 0x");
    }
    while (isHexDigit(peek()) && !atEnd()) {
      tick();
    }
    const s = slice().replace("0x", "");
    const n = Number.parseInt(s, 16);
    return makeToken(TokenType.integer).lit(n);
  };

  const ntoken = (
    numberString: string,
    type: NumberTokenType,
    hasSeparators: boolean
  ) => {
    const n = hasSeparators ? numberString.replaceAll("_", "") : numberString;
    switch (type) {
      case TokenType.integer: {
        const num = Number.parseInt(n);
        return makeToken(TokenType.integer).lit(num);
      }
      case TokenType.float: {
        const num = Number.parseFloat(n);
        return makeToken(TokenType.float).lit(num);
      }
      case TokenType.scientific: {
        const [a, b] = n.split("E");
        const base = Number.parseFloat(a);
        const exponent = Number.parseInt(b);
        return makeToken(type).lit(tuple(base, exponent));
      }
      case TokenType.fraction: {
        const [a, b] = n.split("|");
        const N = Number.parseInt(a);
        const D = Number.parseInt(b);
        return makeToken(type).lit(tuple(N, D));
      }
      default: {
        return errorToken(`Unknown number type: "${numberString}"`);
      }
    }
  };

  /** Returns a number token. */
  const numberToken = (initialType: NumberTokenType) => {
    let type = initialType;
    let scannedSeparators = false;
    while (isDigit(peek()) && !atEnd()) {
      tick();
    }

    // Handle numbers with separators.
    if (peek() === "_" && isDigit(peekNext())) {
      tick();
      scannedSeparators = true;
      let digits = 0;
      while (isDigit(peek()) && !atEnd()) {
        tick();
        digits++;
        if (peek() === "_" && isDigit(peekNext())) {
          if (digits === 3) {
            tick();
            digits = 0;
          } else {
            return errorToken("There must be 3 digits before the separator _");
          }
        }
      }
      if (digits !== 3) {
        return errorToken("There must be 3 digits before the separator _");
      }
    }

    // Handle floating point numbers.
    if (peek() === "." && isDigit(peekNext())) {
      tick();
      type = TokenType.float;
      while (isDigit(peek()) && !atEnd()) {
        tick();
      }
    }

    // Handle fractions.
    // Fractions take the form `[int] | [int]`
    if (peek() === "|") {
      if (type !== TokenType.integer) {
        return errorToken("Expected an integer before '|'");
      }
      type = TokenType.fraction;
      console.log("hit");
      tick();
      while (isDigit(peek()) && !atEnd()) {
        tick();
      }
      return ntoken(slice(), type, scannedSeparators);
    }

    // Handle scientific numbers
    if (peek() === "E") {
      if (isDigit(peekNext())) {
        type = TokenType.scientific;
        tick();
        while (isDigit(peek())) {
          tick();
        }
      } else if (
        (peekNext() === "+" || peekNext() === "-") &&
        isDigit(lookup(2))
      ) {
        type = TokenType.scientific;
        tick(); // eat the 'E'
        tick(); // eat the '+' or '-'
        while (isDigit(peek())) tick();
      }
    }
    return ntoken(slice(), type, scannedSeparators);
  };

  /** The scanning function. */
  const scan = () => {
    skipWhitespace();
    $start = $current;
    if (atEnd()) {
      return makeToken(TokenType.eof);
    }
    const c = tick();
    if (isValidName(c)) {
      return word();
    }
    if (isDigit(c)) {
      if (c === "0" && match("b")) {
        return binaryNumber();
      } else if (c === "0" && match("o")) {
        return octalNumber();
      } else if (c === "0" && match("x")) {
        return hexNumber();
      } else {
        return numberToken(TokenType.integer);
      }
    }
    switch (c) {
      case "(":
        return makeToken(TokenType.left_paren);
      case ")":
        return makeToken(TokenType.right_paren);
      case "{":
        return makeToken(TokenType.left_brace);
      case "}":
        return makeToken(TokenType.right_brace);
      case "[":
        return makeToken(TokenType.left_bracket);
      case "]":
        return makeToken(TokenType.right_bracket);
      case ":":
        return makeToken(TokenType.colon);
      case "|":
        return makeToken(TokenType.vbar);
      case "&":
        return makeToken(TokenType.ampersand);
      case ";":
        return makeToken(TokenType.semicolon);
      case ",":
        return makeToken(TokenType.comma);
      case ".":
        return makeToken(TokenType.dot);
      case "-":
        return makeToken(TokenType.minus);
      case "+":
        return makeToken(TokenType.plus);
      case "/":
        return makeToken(TokenType.slash);
      case "*":
        return makeToken(TokenType.star);
      case "^":
        return makeToken(TokenType.caret);
      case "%":
        return makeToken(TokenType.percent);
      case "!":
        return makeToken(match("=") ? TokenType.equal_equal : TokenType.equal);
      case "=":
        return makeToken(match("=") ? TokenType.equal_equal : TokenType.equal);
      case "<":
        return makeToken(match("=") ? TokenType.less_equal : TokenType.less);
      case ">":
        return makeToken(
          match("=") ? TokenType.greater_equal : TokenType.greater
        );
      case `"`:
        return stringLiteral();
    }

    return errorToken(`Unexpected character: ${c}`);
  };

  /** Scans the entire source code for tokens at once. */
  const stream = () => {
    const out: Token[] = [];
    let prev: Token<any, any> = Token.empty;
    let now = scan();
    if (!now.isType(TokenType.empty)) {
      out.push(now);
    }
    let peek = scan();
    while (!atEnd()) {
      prev = now;
      now = peek;
      const k = scan();
      if (k.isType(TokenType.empty)) {
        continue;
      } else {
        peek = k;
      }
      out.push(now);
    }
    out.push(peek);
    return out;
  };

  const isDone = () => $current >= source.length;

  return {
    stream,
    scan,
    isDone,
  };
}

class ParserState<STMT, EXPR> {
  /** Indicates whether an error has occurred. */
  ERROR: null | Erratum = null;

  /** Given an error object, initializes the state's ERROR field. */
  panic(error: Erratum) {
    this.ERROR = error;
    return this;
  }

  /** This parser state's lexer. */
  private lexer!: ReturnType<typeof lexical>;

  /** Initializes this parser's state. */
  init(source: string) {
    this.lexer = lexical(source);
  }

  /** The last token parsed. */
  prev: Token = Token.empty;

  /** Where the parser currently is. */
  cursor: number = -1;

  /** The next token to parse. */
  peek: Token = Token.empty;

  /** The current token to parse. */
  current: Token = Token.empty;

  /** This parser state's source code. */
  source: string = "";

  /** The last expression parsed. */
  lastExpression: EXPR;

  /** The current expression to parse. */
  currentExpression: EXPR;

  /** The last statement parsed. */
  lastStmt: STMT;

  /** The current statement parsed. */
  currentStmt: STMT;
  constructor(nilExpression: EXPR, emptyStmt: STMT) {
    this.lastExpression = nilExpression;
    this.currentExpression = nilExpression;
    this.lastStmt = emptyStmt;
    this.currentStmt = emptyStmt;
  }

  /** Returns a successfully parsed expression. */
  newExpression<E extends EXPR>(expression: E) {
    const prev = this.currentExpression;
    this.currentExpression = expression;
    this.lastExpression = prev;
    return right(expression);
  }

  /** Returns a successfully parsed statement. */
  newStmt<S extends STMT>(statement: S) {
    const prev = this.currentStmt;
    this.currentStmt = statement;
    this.lastStmt = prev;
    const out = right(statement);
    return out;
  }

  /**
   * Moves the parser state forward.
   */
  next() {
    this.cursor++;
    this.current = this.peek;
    const nextToken = this.lexer.scan();
    if (nextToken.isErrorToken()) {
      this.ERROR = nextToken.literal;
      return Token.end;
    } else {
      this.peek = nextToken;
      return this.current;
    }
  }

  /**
   * Returns true if parsing is complete.
   * Parsing is complete if the lexer has completed scanning,
   * or if the parser state has reached an error.
   */
  atEnd() {
    return this.lexer.isDone() || this.ERROR !== null;
  }

  /**
   * Returns a failed result containing an error.
   * @param message - What message should the error display?
   * @param phase - What phase did this error occur in?
   */
  error(message: string, phase: string) {
    const e = syntaxError(message, phase, this.current);
    this.ERROR = e;
    return left(e);
  }

  /**
   * Returns true if the next token matches the given
   * tokenType, false otherwise.
   */
  check(tokenType: TokenType) {
    if (this.atEnd()) {
      return false;
    } else {
      return this.peek.isType(tokenType);
    }
  }

  /**
   * If the next token matches the given type,
   * the parser moves forward (consuming
   * the token) and returns true. Otherwise, returns
   * false and the parser does not move forward.
   */
  nextIs(tokenType: TokenType) {
    if (this.peek.isType(tokenType)) {
      this.next();
      return true;
    } else {
      return false;
    }
  }
}

interface Visitor<T> {
  expressionStatement(node: ExpressionStatement): T;
}

/**
 * An object corresponding to an
 * Abstract Syntax Tree (AST) node.
 */
abstract class ASTNode {
  abstract accept<T>(visitor: Visitor<T>): T;
}

/**
 * An object corresponding to a Winnow statement.
 */
abstract class Statement extends ASTNode {}

/**
 * An object corresponding to an expression statement.
 */
class ExpressionStatement extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.expressionStatement(this);
  }
}

/**
 * An object corresponding to a Winnow expression.
 */
abstract class Expression extends ASTNode {}



const enstate = <EXPR, STMT>(nilExpression: EXPR, emptyStatement: STMT) =>
  new ParserState(nilExpression, emptyStatement);

/** Parses the given source code. */
function syntax(source: string) {
  // const state = enstate(nil(), )
}
